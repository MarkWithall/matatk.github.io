@media screen {
	/* Define the padding that's applied around the slides */
	:root {
		--gutter-vertical: 0.25rem;
		--gutter-horizontal: 1rem;
	}

	/* This just makes everything make sense */
	* { box-sizing: border-box; }

	/* Scale the root em size as requested by the user */
	html {
		font-size: var(--computed-base-font-size);
		margin: 0;
		padding: 0;
	}

	body {
		margin: 0;
		padding: 0;
	}

	/* Non-current slides shouldn't be shown */
	.slide { display: none; }

	/* The current slide should be as large as it can be to fit within the
	 * screen. The author-desired aspect ratio of the slides is a CSS variable.
	 * The script works out the dimensions of the slides in pixels and stores
	 * them in other CSS variables.
	 *
	 * The base font size is specified by the author as a percentage of the
	 * slide height, so that things are nicely scaleable. Again, the script
	 * works out what this font size is in pixels.
	 *
	 * The script sets the slide's layout to flex. This allows the entire
	 * slide's contents to expand to fill the slide, which allows effects such
	 * as positioning content vertically at the bottom of the slide (or the
	 * middle).
	 *
	 * It's assumed that most slides will be simple text/lists/images and will
	 * want some padding (as defined above) by default. */
	.slide.active {
		position: absolute;
		width: var(--computed-slide-width);
		height: var(--computed-slide-height);
		max-width: var(--computed-slide-width);
		max-height: var(--computed-slide-height);
		margin-top: calc((100vh - var(--computed-slide-height)) / 2);
		margin-bottom: calc((100vh - var(--computed-slide-height)) / 2);
		margin-left: calc((100vw - var(--computed-slide-width)) / 2);
		margin-right: calc((100vw - var(--computed-slide-width)) / 2);
		padding: var(--gutter-vertical) var(--gutter-horizontal);
		/* overflow: hidden; */  /* Not needed if sizing things correctly */
		display: flex;
		flex-direction: column;
	}

	/* Support vertical splitting of content within part of a slide. */
	/* TODO: unused currently - but could be useful? */
	.slide.active [data-split] {  /* doesn't match slide but that's above */
		display: flex;
		flex-direction: column;
	}

	/* TODO: don't think horizontal styles are working or being used ATM */
	/* FIXME: horizontal + bottom on the slide doesn't work */
	.slide.horizontal { flex-direction: row; }

	/* Slides that have the class of (top|middle|bottom) or elements within
	 * slides that have one of those classes should align their content
	 * vertically accordingly. To do this, they are rendred as flexboxes (the
	 * slides themselves already are). */
	.slide.active.top:not(.horizontal),
	.slide.active .top {
		display: flex;
		flex-direction: column;
		justify-content: flex-start;
		height: 100%;
		width: 100%;
	}
	.slide.active.bottom:not(.horizontal),
	.slide.active .bottom {
		display: flex;
		flex-direction: column;
		justify-content: flex-end;
		height: 100%;
		width: 100%;
	}
	.slide.active.middle:not(.horizontal),
	.slide.active .middle {
		display: flex;
		flex-direction: column;
		justify-content: center;
		height: 100%;
		width: 100%;
	}

	/* Some slides will want to take up the full space, with no padding. This
	 * can be used to achieve some effects, such as full-height/-width
	 * backgrounds. */
	.slide.active.full { padding: 0; }

	/* If a slide asked to use the full-size layout /only/ so that it could
	 * have full-height/-width background colours - and actually /does/ want
	 * the normal padding around its text content - then the class "padded" can
	 * be added to insert the padding back in inside each top-level slide
	 * content child element. */
	.slide.active.full.padded > :first-child {
		padding-top: var(--gutter-vertical);
		padding-left: var(--gutter-horizontal);
		padding-right: var(--gutter-horizontal);
	}
	.slide.active.full.padded > * {
		padding-left: var(--gutter-horizontal);
		padding-right: var(--gutter-horizontal);
	}
	.slide.active.full.padded > :last-child {
		padding-left: var(--gutter-horizontal);
		padding-right: var(--gutter-horizontal);
		padding-bottom: var(--gutter-vertical);
	}

	/* If the "centre" (or "center") class was added to a slide, the user wants
	 * the text centred horizontally. This needs to be passed on to the
	 * script-created <div>. */
	.slide.active.centre,
	.slide.active.center { text-align: center; }

	/* Likewise if the user wanted right-aligned content. */
	.slide.active.right { text-align: right; }

	/* Slides can be split into different vertical (or TODO horizontal) parts.
	 * The author can specify the allocation of space to each of these parts,
	 * but if they don't we need a sensible default. By making each part
	 * equally greedy for the whole space, we arrive at each part being
	 * allocated (1/n)th of the space. */
	[data-split] > * { flex-basis: 100%; }

	/* By default, assume that images want to be as big as they can be to fill
	 * the slide. */
	img {
		width: 100%;
		height: 100%;
		object-fit: contain;
	}

	/* The progress bar is a container with nested <div> that adjusts its
	 * width. Got this neat trick from impress.js; thanks :-). */
	#progress {
		display: block;
		position: absolute;
		right: 0;
		left: 0;
		bottom: 0;
	}
	#progress > div { width: 0; }

	/* Previous slide and next slide invisible buttons are used to move between
	 * slides on mobile devices - this avoided the need for custom gesture
	 * detection (e.g. swipe between slides), which would've blocked
	 * pinch-to-zoom gestures. */
	#previous, #next {
		background: none;
		position: absolute;
		top: 0;
		bottom: 0;
		width: 33vw;
		z-index: 42;
		border: none;
	}
	#previous { left: 0; }
	#next { right: 0; }

	/* When the previous/next buttons get focus, show large back/forward arrows
	 * within them, to indicate their purpose. Drop-shadows are used to improve
	 * contrast. */
	#previous > span, #next > span {
		display: none;
	}
	#previous:focus > span, #next:focus > span {
		display: inline;
		color: white;
		font-size: 30vw;
		visibility: visible;
		filter: drop-shadow(0 0 0.05em black);
	}

	/* A button is added at the top of the page to move to story mode. This is
	 * the same as pressing the 's' key, but is more easily discoverable by
	 * screen-reader and mobile users.
	 *
	 * The same technique is used in general to hide stuff visually but not
	 * from assistive technologies such as screen-readers. */
	/* FIXME: Something about this is making iOS Safari think that the page is
	 * taller than a slide, and the story mode button triggers editing the
	 * address bar. */
	#mode-button, .visually-hidden {
		position: absolute;
		clip: rect(1px, 1px, 1px, 1px);
		padding: 0;
		border: 0;
		height: 1px;
		width: 1px;
		overflow: hidden;
		white-space: nowrap;
	}
	#mode-button:focus {
		/* Requiredeties */
		overflow: visible;
		height: auto;
		width: auto;
		clip: auto;
		/* Niceties */
		top: calc((100vh - var(--computed-slide-height)) / 2);
		left: calc((100vw - var(--computed-slide-width)) / 2);
		font-size: inherit;
		padding: 0.5em;
		border: 0.1em solid white;
		border-radius: 0.5em;
		background-color: black;
		color: white;
	}

	/* Story mode content should not be available to anyone when we are in
	 * slides mode, which we are if this stylesheet is loaded. */
	.story { display: none; }

	/* The story mode button needs to be 'on top' of the previous slide button,
	 * too :-). */
	#mode-button { z-index: 43; }
}
